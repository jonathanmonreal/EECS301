
// The top-level Verilog file for eecs301_lab3
// This code was initially generated by Terasic System Builder

module eecs301_lab3(

         //////////// ADC //////////
         output ADC_CONVST,
         output ADC_DIN,
         input ADC_DOUT,
         output ADC_SCLK,

         //////////// CLOCK //////////
         input CLOCK_50,
         input CLOCK2_50,
         input CLOCK3_50,
         input CLOCK4_50,

         //////////// SEG7 //////////
         output [ 6: 0 ] HEX0,
         output [ 6: 0 ] HEX1,
         output [ 6: 0 ] HEX2,
         output [ 6: 0 ] HEX3,
         output [ 6: 0 ] HEX4,
         output [ 6: 0 ] HEX5,

         //////////// KEY //////////
         input [ 3: 0 ] KEY,

         //////////// LED //////////
         output [ 9: 0 ] LEDR,

         //////////// SW //////////
         input [ 9: 0 ] SW,

         //////////// VGA //////////
         output [ 7: 0 ] VGA_B,
         output VGA_BLANK_N,
         output VGA_CLK,
         output [ 7: 0 ] VGA_G,
         output VGA_HS,
         output [ 7: 0 ] VGA_R,
         output VGA_SYNC_N,
         output VGA_VS,

         //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_0,

         //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_1
       );

//=======================================================
//  REG/WIRE declarations
//=======================================================

wire SYNC;
wire SCLK;
wire Din;
wire LDAC;
wire CLR;
assign GPIO_0[10] = ~SYNC;
assign GPIO_0[8] = SCLK;
assign GPIO_0[9] = Din;
assign GPIO_0[11] = ~LDAC;
assign GPIO_0[12] = ~CLR;

// Switch and button definitions
wire variable = ~SW[0];
wire enable_SPI = ~SW[1];
wire reset = ~KEY[0];
wire down = ~KEY[1];
wire up = ~KEY[2];

// Amplitude and frequency registers
wire [9:0] amplitude;
wire [9:0] frequency;

// Temporary

assign LEDR = amplitude;

wire [11:0] nco_data;
wire [23:0] phi_input;
wire [11:0] dac_data;
wire [31:0] dac_in;
wire slow_clk;
wire button_freq;
wire load;
wire load2;
assign dac_in[19:8] = dac_data;
assign dac_in[23:20] = 4'b0000; // address
assign dac_in[27:24] = 4'b0011; // command
assign SCLK = CLOCK_50;
assign LDAC = ~ldacp;
assign SYNC = ~syncp;

//=======================================================
//  Structural coding
//=======================================================

clock_divider slow(
	.clk(CLOCK_50),
	.clk_out(slow_clk)
);

button_clock bc(
	.clk(CLOCK_50),
	.clk_out(button_freq)
);

sync_pulse pulse(
.clk_in(CLOCK_50), .x_in(8'b11011000), .threshold(8'b11111000), .PWM_out(syncp)
);

ldac_pulse pul(
.clk_in(CLOCK_50), .left(8'b11111010), .right(8'b11111110), .PWM_out(ldacp)
);



controller control(
	.clk(button_freq),
	.rst(reset),
	.variable(variable),
	.down(down),
	.up(up),
	.amp(amplitude),
	.freq(frequency)
);

gain_control ampcontrol(
	.clk(CLOCK_50),
	.in(nco_data),
	.k(amplitude),
	.out(dac_data)
);

freq_control freqcontrol(
	.clk(CLOCK_50),
	.in(frequency),
	.out(phi_input)
);

shiftreg sr(
	.clock(CLOCK_50),
	.data(dac_in),
	.enable(1'b1),
	.load(syncp),
	.shiftout(Din)
);

NCO generator(
		.clk(CLOCK_50),       // clk.clk
		.clken(1'b1),     //  in.clken
		.phi_inc_i(phi_input), //0011010001101110    .phi_inc_i
		.fsin_o(nco_data),    // out.fsin_o
		.out_valid(), //    .out_valid
		.reset_n(~reset)
);

endmodule
